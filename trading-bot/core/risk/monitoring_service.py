"""
Real-time risk monitoring service for continuous risk assessment and alerting.
"""
from __future__ import annotations

import asyncio
import logging
import time
from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from decimal import Decimal
from enum import Enum
from typing import (
    Any, Dict, List, Optional, Set, Tuple, Callable, Awaitable, Union,
    DefaultDict
)
import json
import websockets
from collections import deque

from ..market.market_data_service import MarketDataService
from .risk_manager import RiskManager, RiskViolation, RiskViolationType, RiskSeverity

logger = logging.getLogger(__name__)

class AlertLevel(Enum):
    """Alert severity levels."""
    INFO = "INFO"
    WARNING = "WARNING"
    CRITICAL = "CRITICAL"
    EMERGENCY = "EMERGENCY"

@dataclass
class Alert:
    """A risk alert generated by the monitoring service."""
    id: str
    timestamp: datetime
    level: AlertLevel
    message: str
    source: str
    details: Dict[str, Any] = field(default_factory=dict)
    acknowledged: bool = False
    resolved: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert alert to dictionary."""
        return {
            'id': self.id,
            'timestamp': self.timestamp.isoformat(),
            'level': self.level.value,
            'message': self.message,
            'source': self.source,
            'details': self.details,
            'acknowledged': self.acknowledged,
            'resolved': self.resolved
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Alert':
        """Create an alert from a dictionary."""
        return cls(
            id=data['id'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            level=AlertLevel(data['level']),
            message=data['message'],
            source=data['source'],
            details=data.get('details', {}),
            acknowledged=data.get('acknowledged', False),
            resolved=data.get('resolved', False)
        )

class RiskMonitor:
    """
    Real-time risk monitoring service that continuously tracks trading activity
    and risk metrics, generating alerts and triggering circuit breakers when needed.
    """
    
    def __init__(
        self,
        risk_manager: RiskManager,
        market_data: MarketDataService,
        check_interval: float = 5.0,  # seconds
        alert_history_size: int = 1000,
        websocket_port: int = 8765
    ):
        """Initialize the risk monitoring service."""
        self.risk_manager = risk_manager
        self.market_data = market_data
        self.check_interval = check_interval
        self.websocket_port = websocket_port
        
        # Alert management
        self.alerts: Dict[str, Alert] = {}
        self.alert_history: deque[Alert] = deque(maxlen=alert_history_size)
        self.alert_callbacks: List[Callable[[Alert], Awaitable[None]]] = []
        
        # WebSocket server for real-time alerts
        self.websocket_server = None
        self.websocket_clients: Set[websockets.WebSocketServerProtocol] = set()
        
        # Monitoring tasks
        self._monitoring_task: Optional[asyncio.Task] = None
        self._running = False
        
        # Register violation callback
        self.risk_manager._on_risk_violation = self._on_risk_violation
    
    async def start(self) -> None:
        """Start the monitoring service."""
        if self._running:
            return
            
        logger.info("Starting Risk Monitoring Service...")
        self._running = True
        
        # Start monitoring task
        self._monitoring_task = asyncio.create_task(self._monitor_loop())
        
        # Start WebSocket server
        self.websocket_server = await websockets.serve(
            self._websocket_handler,
            '0.0.0.0',
            self.websocket_port
        )
        
        logger.info(f"Risk Monitoring Service started on WebSocket port {self.websocket_port}")
    
    async def stop(self) -> None:
        """Stop the monitoring service."""
        if not self._running:
            return
            
        logger.info("Stopping Risk Monitoring Service...")
        self._running = False
        
        # Cancel monitoring task
        if self._monitoring_task and not self._monitoring_task.done():
            self._monitoring_task.cancel()
            try:
                await self._monitoring_task
            except asyncio.CancelledError:
                pass
        
        # Close WebSocket server
        if self.websocket_server:
            self.websocket_server.close()
            await self.websocket_server.wait_closed()
        
        # Close all WebSocket connections
        if self.websocket_clients:
            await asyncio.gather(*[
                client.close() for client in self.websocket_clients
            ])
        
        logger.info("Risk Monitoring Service stopped")
    
    async def _monitor_loop(self) -> None:
        """Main monitoring loop."""
        while self._running:
            try:
                # Check portfolio risk
                await self.risk_manager.check_portfolio_risk()
                
                # Check market conditions
                await self._check_market_conditions()
                
                # Check for stale alerts
                await self._check_stale_alerts()
                
                # Wait for next check
                await asyncio.sleep(self.check_interval)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}", exc_info=True)
                await asyncio.sleep(5)  # Prevent tight loop on errors
    
    async def _check_market_conditions(self) -> None:
        """Check market conditions that might affect risk."""
        try:
            # Example: Check for high volatility
            # In a real implementation, this would fetch market data
            # and calculate volatility metrics
            pass
            
            # Example: Check for news events
            # This would integrate with a news API or event feed
            
            # Example: Check for liquidity conditions
            # This would analyze order book depth and spread
            
        except Exception as e:
            logger.error(f"Error checking market conditions: {e}", exc_info=True)
    
    async def _check_stale_alerts(self) -> None:
        """Check for and update stale alerts."""
        now = datetime.now(timezone.utc)
        stale_threshold = timedelta(hours=1)  # Alerts older than this are considered stale
        
        for alert in list(self.alerts.values()):
            if not alert.resolved and (now - alert.timestamp) > stale_threshold:
                # Auto-resolve or escalate stale alerts
                if alert.level == AlertLevel.WARNING:
                    await self.resolve_alert(alert.id, "Auto-resolved stale warning")
                else:
                    # Escalate critical alerts
                    await self.escalate_alert(alert.id, "Alert not acknowledged")
    
    async def _on_risk_violation(self, violation: RiskViolation) -> None:
        """Handle a risk violation from the risk manager."""
        # Map risk severity to alert level
        level_map = {
            RiskSeverity.INFO: AlertLevel.INFO,
            RiskSeverity.WARNING: AlertLevel.WARNING,
            RiskSeverity.ERROR: AlertLevel.CRITICAL,
            RiskSeverity.CRITICAL: AlertLevel.EMERGENCY
        }
        
        # Create a new alert
        alert = Alert(
            id=f"alert_{int(time.time())}_{len(self.alerts)}",
            timestamp=datetime.now(timezone.utc),
            level=level_map.get(violation.severity, AlertLevel.WARNING),
            message=violation.message,
            source=f"risk_manager.{violation.violation_type.value.lower()}",
            details={
                'violation_type': violation.violation_type.value,
                'severity': violation.severity.value,
                **violation.details
            }
        )
        
        # Add to active alerts
        self.alerts[alert.id] = alert
        self.alert_history.append(alert)
        
        # Broadcast to WebSocket clients
        await self._broadcast_alert(alert)
        
        # Trigger callbacks
        for callback in self.alert_callbacks:
            try:
                await callback(alert)
            except Exception as e:
                logger.error(f"Error in alert callback: {e}", exc_info=True)
        
        logger.info(f"New alert: {alert.level.value} - {alert.message}")
    
    async def add_alert(
        self,
        level: Union[AlertLevel, str],
        message: str,
        source: str,
        details: Optional[Dict[str, Any]] = None
    ) -> Alert:
        """Add a custom alert."""
        if isinstance(level, str):
            level = AlertLevel(level.upper())
            
        alert = Alert(
            id=f"alert_{int(time.time())}_{len(self.alerts)}",
            timestamp=datetime.now(timezone.utc),
            level=level,
            message=message,
            source=source,
            details=details or {}
        )
        
        self.alerts[alert.id] = alert
        self.alert_history.append(alert)
        
        # Broadcast to WebSocket clients
        await self._broadcast_alert(alert)
        
        logger.info(f"New alert: {alert.level.value} - {alert.message}")
        return alert
    
    async def acknowledge_alert(self, alert_id: str, user: str = "system") -> bool:
        """Acknowledge an alert."""
        if alert_id not in self.alerts:
            return False
            
        alert = self.alerts[alert_id]
        alert.acknowledged = True
        alert.details['acknowledged_by'] = user
        alert.details['acknowledged_at'] = datetime.now(timezone.utc).isoformat()
        
        # Broadcast update
        await self._broadcast_alert(alert)
        
        logger.info(f"Alert {alert_id} acknowledged by {user}")
        return True
    
    async def resolve_alert(self, alert_id: str, resolution: str, user: str = "system") -> bool:
        """Resolve an alert."""
        if alert_id not in self.alerts:
            return False
            
        alert = self.alerts[alert_id]
        alert.resolved = True
        alert.details['resolved_by'] = user
        alert.details['resolved_at'] = datetime.now(timezone.utc).isoformat()
        alert.details['resolution'] = resolution
        
        # Remove from active alerts
        self.alerts.pop(alert_id, None)
        
        # Broadcast update
        await self._broadcast_alert(alert, is_resolution=True)
        
        logger.info(f"Alert {alert_id} resolved by {user}: {resolution}")
        return True
    
    async def escalate_alert(self, alert_id: str, reason: str) -> bool:
        """Escalate an alert to a higher severity level."""
        if alert_id not in self.alerts:
            return False
            
        alert = self.alerts[alert_id]
        
        # Determine next severity level
        levels = list(AlertLevel)
        current_idx = levels.index(alert.level)
        if current_idx < len(levels) - 1:
            alert.level = levels[current_idx + 1]
            alert.details['escalated_at'] = datetime.now(timezone.utc).isoformat()
            alert.details['escalation_reason'] = reason
            
            # Broadcast update
            await self._broadcast_alert(alert)
            
            logger.warning(f"Alert {alert_id} escalated to {alert.level.value}: {reason}")
            return True
            
        return False
    
    def register_alert_callback(self, callback: Callable[[Alert], Awaitable[None]]) -> None:
        """Register a callback for new alerts."""
        self.alert_callbacks.append(callback)
    
    async def _broadcast_alert(self, alert: Alert, is_resolution: bool = False) -> None:
        """Broadcast an alert to all connected WebSocket clients."""
        if not self.websocket_clients:
            return
            
        message = {
            'type': 'alert_resolution' if is_resolution else 'alert',
            'data': alert.to_dict()
        }
        
        # Send to all connected clients
        message_json = json.dumps(message, default=str)
        await asyncio.gather(
            *[client.send(message_json) for client in self.websocket_clients],
            return_exceptions=True
        )
    
    async def _websocket_handler(self, websocket: websockets.WebSocketServerProtocol, path: str) -> None:
        """Handle WebSocket connections."""
        # Add client to the set
        self.websocket_clients.add(websocket)
        logger.info(f"New WebSocket connection: {websocket.remote_address}")
        
        try:
            # Send initial state (all active alerts)
            if self.alerts:
                message = {
                    'type': 'initial_state',
                    'data': [alert.to_dict() for alert in self.alerts.values()]
                }
                await websocket.send(json.dumps(message, default=str))
            
            # Keep the connection open
            async for message in websocket:
                try:
                    # Handle incoming messages (e.g., acknowledge/resolve alerts)
                    data = json.loads(message)
                    await self._handle_websocket_message(websocket, data)
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON received from WebSocket: {message}")
                except Exception as e:
                    logger.error(f"Error handling WebSocket message: {e}", exc_info=True)
                    
        except websockets.exceptions.ConnectionClosed:
            logger.info(f"WebSocket connection closed: {websocket.remote_address}")
        except Exception as e:
            logger.error(f"WebSocket error: {e}", exc_info=True)
        finally:
            # Remove client when disconnected
            self.websocket_clients.discard(websocket)
    
    async def _handle_websocket_message(
        self,
        websocket: websockets.WebSocketServerProtocol,
        message: Dict[str, Any]
    ) -> None:
        """Handle incoming WebSocket messages."""
        msg_type = message.get('type')
        data = message.get('data', {})
        
        if msg_type == 'acknowledge_alert':
            alert_id = data.get('alert_id')
            user = data.get('user', 'unknown')
            await self.acknowledge_alert(alert_id, user)
            
        elif msg_type == 'resolve_alert':
            alert_id = data.get('alert_id')
            resolution = data.get('resolution', 'Resolved by user')
            user = data.get('user', 'unknown')
            await self.resolve_alert(alert_id, resolution, user)
            
        elif msg_type == 'escalate_alert':
            alert_id = data.get('alert_id')
            reason = data.get('reason', 'Escalated by user')
            await self.escalate_alert(alert_id, reason)
            
        elif msg_type == 'ping':
            # Respond to ping
            await websocket.send(json.dumps({'type': 'pong'}))

# Example usage:
# monitor = RiskMonitor(risk_manager, market_data)
# await monitor.start()
# 
# # Add a custom alert
# await monitor.add_alert(
#     level="WARNING",
#     message="High volatility detected",
#     source="volatility_monitor",
#     details={"symbol": "BTCUSDT", "volatility": 0.05}
# )
# 
# # Acknowledge an alert
# await monitor.acknowledge_alert("alert_123", "user1")
# 
# # Resolve an alert
# await monitor.resolve_alert("alert_123", "Issue resolved", "user1")
