"""Base strategy class for defining trading strategies."""
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import pandas as pd

from ..models import OHLCV, Order, Position, Ticker, Trade
from ..exchange.base import BaseExchange


class SignalType(Enum):
    """Types of trading signals."""
    BUY = auto()
    SELL = auto()
    HOLD = auto()
    CLOSE = auto()


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    symbol: str
    signal_type: SignalType
    price: float
    timestamp: pd.Timestamp
    confidence: float = 1.0
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    size: Optional[float] = None  # Position size as a percentage of capital or absolute value
    metadata: Dict = field(default_factory=dict)


class BaseStrategy(ABC):
    """Base class for all trading strategies.
    
    Subclasses should implement the `generate_signals` method to define their
    specific trading logic.
    """
    
    def __init__(self, exchange: BaseExchange, config: Optional[Dict] = None):
        """Initialize the strategy.
        
        Args:
            exchange: Exchange client for market data and trading
            config: Strategy configuration parameters
        """
        self.exchange = exchange
        self.config = config or {}
        self.indicators = {}
        self.signals = []
        self.positions = {}
        self.initialized = False
    
    async def initialize(self):
        """Initialize the strategy.
        
        This method is called once when the strategy is first started.
        Use it to load any required data or initialize indicators.
        """
        self.initialized = True
    
    @abstractmethod
    async def generate_signals(self, data: Dict[str, OHLCV]) -> List[Signal]:
        """Generate trading signals based on market data.
        
        This is the main method that subclasses must implement to define
        their trading logic.
        
        Args:
            data: Dictionary of OHLCV data for each symbol being tracked
            
        Returns:
            List of trading signals
        """
        pass
    
    async def on_tick(self, data: Dict[str, Ticker]) -> List[Signal]:
        """Process market data update and generate signals.
        
        This method is called on each market data update. The default
        implementation simply returns an empty list. Override this method
        to implement custom tick-by-tick processing.
        
        Args:
            data: Dictionary of ticker data for each symbol
            
        Returns:
            List of trading signals
        """
        return []
    
    async def on_bar(self, data: Dict[str, OHLCV]) -> List[Signal]:
        """Process new bar data and generate signals.
        
        This method is called when new OHLCV data is available. The default
        implementation calls `generate_signals` with the new data.
        
        Args:
            data: Dictionary of OHLCV data for each symbol
            
        Returns:
            List of trading signals
        """
        return await self.generate_signals(data)
    
    async def on_order_update(self, order: Order):
        """Handle order update events.
        
        This method is called when an order is created, updated, or filled.
        
        Args:
            order: The updated order
        """
        pass
    
    async def on_trade(self, trade: Trade):
        """Handle trade execution events.
        
        This method is called when a trade is executed.
        
        Args:
            trade: The executed trade
        """
        pass
    
    async def on_position_update(self, position: Position):
        """Handle position update events.
        
        This method is called when a position is opened, updated, or closed.
        
        Args:
            position: The updated position
        """
        self.positions[position.symbol] = position
    
    def get_position(self, symbol: str) -> Optional[Position]:
        """Get the current position for a symbol.
        
        Args:
            symbol: Trading pair symbol
            
        Returns:
            Current position or None if no position exists
        """
        return self.positions.get(symbol)
    
    def has_position(self, symbol: str) -> bool:
        """Check if there is an open position for a symbol.
        
        Args:
            symbol: Trading pair symbol
            
        Returns:
            True if there is an open position, False otherwise
        """
        return symbol in self.positions and self.positions[symbol].size > 0
    
    def get_signals(self, limit: int = 100) -> List[Signal]:
        """Get the most recent signals.
        
        Args:
            limit: Maximum number of signals to return
            
        Returns:
            List of recent signals
        """
        return self.signals[-limit:] if self.signals else []
    
    def get_performance_metrics(self) -> Dict:
        """Calculate and return strategy performance metrics.
        
        Returns:
            Dictionary of performance metrics
        """
        # Base implementation returns an empty dict
        # Subclasses should implement their own performance metrics
        return {}
    
    def get_state(self) -> Dict:
        """Get the current state of the strategy.
        
        Returns:
            Dictionary containing the strategy state
        """
        return {
            'initialized': self.initialized,
            'positions': {k: v.to_dict() for k, v in self.positions.items()},
            'config': self.config,
            'indicators': {k: v.tolist() if hasattr(v, 'tolist') else v 
                          for k, v in self.indicators.items()}
        }
    
    def set_state(self, state: Dict):
        """Restore the strategy state.
        
        Args:
            state: Dictionary containing the strategy state
        """
        self.initialized = state.get('initialized', False)
        self.config = state.get('config', {})
        self.indicators = state.get('indicators', {})
        
        # Restore positions
        self.positions = {}
        for symbol, pos_data in state.get('positions', {}).items():
            self.positions[symbol] = Position(**pos_data)
